<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>Puzzle Interactivo Mejorado</title>
<style>
  html, body {
    margin: 0; padding: 0; height: 100%;
    background: #f0f0f0;
    font-family: sans-serif;
    display: flex; flex-direction: column;
    align-items: center; justify-content: flex-start;
  }
  h1 {
    margin: 12px;
  }
  #puzzleWrapper {
    width: 90vw;
    max-width: 1000px;
    aspect-ratio: 3 / 2;
    background: #ddd;
    position: relative;
    border: 5px solid #333;
    overflow: hidden;
    touch-action: none; /* evita gestos nativos en móviles */
  }
  canvas {
    width: 100%; height: 100%; display: block;
    user-select: none;
  }
  #completeMsg {
    display: none;
    position: absolute;
    top: 40%; left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(255,255,255,0.95);
    padding: 20px;
    border: 2px solid #333;
    border-radius: 12px;
    text-align: center;
    z-index: 10;
    font-size: 1.2em;
  }
  #continueBtn, #restartBtn {
    margin-top: 12px;
    padding: 10px 20px;
    background: white;
    color: black;
    border: 2px solid black;
    border-radius: 10px;
    font-size: 1em;
    cursor: pointer;
  }
  #restartBtn {
    margin: 12px;
  }
  /* Adaptación para apaisado (landscape) */
  @media (orientation: landscape) {
    body {
      justify-content: center;
    }
    #puzzleWrapper {
      width: 80vw;
      max-width: 1400px;
      aspect-ratio: 16 / 9;
    }
  }
</style>
</head>
<body>
  <h1>Puzzle Plaza de la Virgen</h1>
  <button id="restartBtn" title="Reiniciar puzzle">🔄 Reiniciar</button>
  <div id="puzzleWrapper">
    <canvas id="puzzleCanvas"></canvas>
    <div id="completeMsg">
      <strong>🎉 Puzzle completado</strong><br />
      <button id="continueBtn">Continuar</button>
    </div>
  </div>

<script>
  const canvas = document.getElementById("puzzleCanvas");
  const ctx = canvas.getContext("2d");
  const imageSrc = "https://i.ibb.co/SXqwg32T/plaza-de-la-virgen-apaisada.jpg";
  const rows = 3;
  const cols = 4;
  let pieces = [];
  let draggingPiece = null;
  let offsetX = 0;
  let offsetY = 0;
  let img = new Image();
  let placedCount = 0;
  const completeMsg = document.getElementById("completeMsg");
  const continueBtn = document.getElementById("continueBtn");
  const restartBtn = document.getElementById("restartBtn");

  // Sonido al colocar pieza
  const placeSound = new Audio("https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg");
  placeSound.volume = 0.3;

  // Animación zoom rápido al colocar pieza
  let animatingPiece = null;
  let animScale = 1;
  let animDirection = 1;
  let animFrame = 0;
  const animFramesTotal = 10;

  window.addEventListener("resize", () => {
    init();
  });

  img.onload = () => init();
  img.src = imageSrc;

  function init() {
    const wrapper = document.getElementById("puzzleWrapper");
    const w = wrapper.clientWidth;
    const h = wrapper.clientHeight;
    canvas.width = w;
    canvas.height = h;
    const pw = w / cols;
    const ph = h / rows;

    pieces = [];
    placedCount = 0;
    completeMsg.style.display = "none";
    wrapper.style.borderColor = "#333";
    animatingPiece = null;
    animScale = 1;

    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        pieces.push({
          sx: c * img.width / cols,
          sy: r * img.height / rows,
          sw: img.width / cols,
          sh: img.height / rows,
          x: Math.random() * (w - pw),
          y: Math.random() * (h - ph),
          w: pw,
          h: ph,
          correctX: c * pw,
          correctY: r * ph,
          placed: false,
          scale: 1,
        });
      }
    }
    draw();
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Dibujar piezas colocadas primero (para que estén debajo)
    for (const p of pieces.filter(p => p.placed)) {
      drawPiece(p);
    }
    // Dibujar piezas no colocadas encima
    for (const p of pieces.filter(p => !p.placed)) {
      drawPiece(p);
    }

    if (animatingPiece) {
      animFrame++;
      animScale += 0.05 * animDirection;
      if (animFrame >= animFramesTotal) {
        animDirection = -animDirection;
      }
      if (animFrame >= animFramesTotal * 2) {
        animatingPiece.scale = 1;
        animatingPiece = null;
        animFrame = 0;
        animDirection = 1;
      } else {
        animatingPiece.scale = animScale;
        requestAnimationFrame(draw);
      }
    }
  }

  function drawPiece(p) {
    ctx.save();
    const cx = p.x + p.w / 2;
    const cy = p.y + p.h / 2;
    ctx.translate(cx, cy);
    ctx.scale(p.scale || 1, p.scale || 1);
    ctx.translate(-cx, -cy);

    ctx.beginPath();
    ctx.rect(p.x, p.y, p.w, p.h);
    ctx.clip();
    ctx.drawImage(img, p.sx, p.sy, p.sw, p.sh, p.x, p.y, p.w, p.h);
    ctx.restore();
    ctx.strokeStyle = "#333";
    ctx.strokeRect(p.x, p.y, p.w, p.h);
  }

  function getPointer(e) {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    return { x, y };
  }

  canvas.addEventListener("mousedown", e => startDrag(e));
  canvas.addEventListener("mousemove", e => onDrag(e));
  canvas.addEventListener("mouseup", () => stopDrag());
  canvas.addEventListener("mouseleave", () => stopDrag());

  canvas.addEventListener("touchstart", e => startDrag(e.touches[0]));
  canvas.addEventListener("touchmove", e => {
    e.preventDefault();
    onDrag(e.touches[0]);
  });
  canvas.addEventListener("touchend", () => stopDrag());

  function startDrag(e) {
    if(animatingPiece) return; // No permitir arrastrar durante animación
    const { x, y } = getPointer(e);
    for (let i = pieces.length - 1; i >= 0; i--) {
      const p = pieces[i];
      if (!p.placed && x >= p.x && x <= p.x + p.w && y >= p.y && y <= p.y + p.h) {
        draggingPiece = p;
        offsetX = x - p.x;
        offsetY = y - p.y;
        // Llevar pieza arrastrada al final del array para que se dibuje encima
        pieces.splice(i, 1);
        pieces.push(p);
        draw();
        break;
      }
    }
  }

  function onDrag(e) {
    if (!draggingPiece) return;
    const { x, y } = getPointer(e);
    draggingPiece.x = Math.min(Math.max(x - offsetX, 0), canvas.width - draggingPiece.w);
    draggingPiece.y = Math.min(Math.max(y - offsetY, 0), canvas.height - draggingPiece.h);
    draw();
  }

  function stopDrag() {
    if (!draggingPiece) return;

    const snap = draggingPiece.w / 4;
    const dx = Math.abs(draggingPiece.x - draggingPiece.correctX);
    const dy = Math.abs(draggingPiece.y - draggingPiece.correctY);

    if (dx < snap && dy < snap) {
      draggingPiece.x = draggingPiece.correctX;
      draggingPiece.y = draggingPiece.correctY;
      draggingPiece.placed = true;
      placedCount++;
      // Mover pieza colocada al final para que no tape las demás
      const idx = pieces.indexOf(draggingPiece);
      if (idx !== -1) {
        pieces.splice(idx, 1);
        pieces.push(draggingPiece);
      }
      placeSound.play();
      animatingPiece = draggingPiece;
      animFrame = 0;
      animScale = 1;
      animDirection = 1;
      draw();
      if (placedCount === pieces.length) {
        onComplete();
      }
    }
    draggingPiece = null;
  }

  function onComplete() {
    const wrapper = document.getElementById("puzzleWrapper");
    wrapper.style.borderColor = "green";
    completeMsg.style.display = "block";
  }

  continueBtn.onclick = () => {
    completeMsg.style.display = "none";
    document.querySelector("h1").textContent = "¡Gracias por jugar!";
  };

  restartBtn.onclick = () => {
    init();
  };

</script>
</body>
</html>
